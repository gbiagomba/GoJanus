diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..f560188
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1 @@
+janus
diff --git a/cmd/root.go b/cmd/root.go
index 41c8044..4272f2c 100644
--- a/cmd/root.go
+++ b/cmd/root.go
@@ -5,8 +5,14 @@ Copyright © 2022 NAME HERE <EMAIL ADDRESS>
 package cmd
 
 import (
+	"crypto/tls"
+	"net"
+	"net/http"
 	"os"
+	"time"
 
+	"github.com/rs/zerolog"
+	"github.com/rs/zerolog/log"
 	"github.com/spf13/cobra"
 )
 
@@ -23,6 +29,7 @@ to quickly create a Cobra application.`,
 	// Uncomment the following line if your bare application
 	// has an action associated with it:
 	// Run: func(cmd *cobra.Command, args []string) { },
+
 }
 
 // Execute adds all child commands to the root command and sets flags appropriately.
@@ -34,6 +41,16 @@ func Execute() {
 	}
 }
 
+const (
+	headerTimeout = 3 * time.Second
+	dialTimeout   = 1 * time.Second
+)
+
+var (
+	httpClient                *http.Client
+	consoleLogger, jsonLogger zerolog.Logger
+)
+
 func init() {
 	// Here you will define your flags and configuration settings.
 	// Cobra supports persistent flags, which, if defined here,
@@ -41,7 +58,33 @@ func init() {
 
 	// rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/.GoJanus.yaml)")
 
+	// Setup our HTTP Client
+	dialer := &net.Dialer{
+		Timeout: dialTimeout,
+	}
+
+	tr := &http.Transport{
+		ResponseHeaderTimeout: headerTimeout,
+		TLSClientConfig:       &tls.Config{InsecureSkipVerify: true},
+		DialContext:           dialer.DialContext,
+	}
+	httpClient = &http.Client{Transport: tr}
+
+	// Setup Our Logger
+	level := zerolog.DebugLevel
+
+	consoleOutput := zerolog.ConsoleWriter{
+		Out:        os.Stdout,
+		TimeFormat: zerolog.TimeFormatUnix,
+	}
+	consoleLogger = zerolog.New(consoleOutput).With().Logger().Level(level)
+
+	jsonLogger = zerolog.New(os.Stdout).With().Logger().Level(level)
+
+	log.Logger = consoleLogger
+
 	// Cobra also supports local flags, which will only run
 	// when this action is called directly.
 	rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
+
 }
diff --git a/cmd/scan.go b/cmd/scan.go
index 65f263d..803fd26 100644
--- a/cmd/scan.go
+++ b/cmd/scan.go
@@ -5,13 +5,10 @@ Copyright © 2022 NAME HERE <EMAIL ADDRESS>
 package cmd
 
 import (
-	"crypto/tls"
-	"fmt"
 	"io"
-	"log"
 	"net/http"
 
-	"github.com/rs/zerolog"
+	"github.com/rs/zerolog/log"
 	"github.com/spf13/cobra"
 )
 
@@ -26,8 +23,13 @@ Cobra is a CLI library for Go that empowers applications.
 This application is a tool to generate the needed files
 to quickly create a Cobra application.`,
 	Run: func(cmd *cobra.Command, args []string) {
+		jsonLogs, _ := cmd.Flags().GetBool("json")
+		if jsonLogs {
+			log.Logger = jsonLogger
+		}
+
 		url, _ := cmd.Flags().GetString("url-target")
-		err := scan(url)
+		err := scan(url, httpClient)
 		if err != nil {
 			log.Printf("Scanning encountered an error,%v", err)
 		}
@@ -47,45 +49,65 @@ func init() {
 	// is called directly, e.g.:
 	scanCmd.Flags().StringP("url-target", "u", "", "Specify the target url (http://www.example.com)")
 	scanCmd.MarkFlagRequired("url-target")
+
+	scanCmd.Flags().BoolP("json", "j", false, "Output JSON Results")
+}
+
+type scanResult struct {
+	StatusCode int
+	Body       string
+}
+
+func scanSpecific(method string, url string, thisClient *http.Client) (*scanResult, error) {
+	req, err := http.NewRequest(method, url, nil)
+	if err != nil {
+		return nil, err
+	}
+
+	resp, err := thisClient.Do(req)
+	if err != nil {
+		return nil, err
+	}
+	defer resp.Body.Close()
+
+	bodyBytes, err := io.ReadAll(resp.Body)
+	if err != nil {
+		return nil, err
+	}
+	bodyString := string(bodyBytes)
+
+	return &scanResult{
+		StatusCode: resp.StatusCode,
+		Body:       bodyString,
+	}, nil
 }
 
-func scan(urlString string) error {
+func scan(urlString string, client *http.Client) error {
 	// Initialiing http methods
 	httpMethods := []string{"ACL", "BASELINE-CONTROL", "BCOPY", "BDELETE", "BMOVE", "BPROPFIND", "BPROPPATCH", "CHECKIN", "CHECKOUT", "CONNECT", "COPY", "DEBUG", "DELETE", "GET", "HEAD", "INDEX", "LABEL", "LOCK", "MERGE", "MKACTIVITY", "MKCOL", "MKWORKSPACE", "MOVE", "NOTIFY", "OPTIONS", "ORDERPATCH", "PATCH", "POLL", "POST", "PROPFIND", "PROPPATCH", "PUT", "REPORT", "RPC_IN_DATA", "RPC_OUT_DATA", "SEARCH", "SUBSCRIBE", "TRACE", "UNCHECKOUT", "UNLOCK", "UNSUBSCRIBE", "UPDATE", "VERSION-CONTROL", "X-MS-ENUMATTS"}
 	// UNIX Time is faster and smaller than most timestamps
-	zerolog.TimeFieldFormat = zerolog.TimeFormatUnix
 
 	for _, method := range httpMethods {
-		// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
-		// curl -k -L -s -x ACL https://example.com
-		// TODO: This is insecure; use only in dev environments.
-		tr := &http.Transport{
-			TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
-		}
-		client := &http.Client{Transport: tr}
-
-		req, err := http.NewRequest(method, urlString, nil)
-		if err != nil {
-			return err
-		}
 
-		resp, err := client.Do(req)
+		resp, err := scanSpecific(method, urlString, client)
 		if err != nil {
 			return err
 		}
-		defer resp.Body.Close()
 
 		switch resp.StatusCode {
 		case http.StatusOK:
-			bodyBytes, err := io.ReadAll(resp.Body)
-			if err != nil {
-				return err
-			}
-			bodyString := string(bodyBytes)
-			fmt.Println(resp.Request.URL)
-			log.Printf("%s\n", bodyString)
+			log.Info().
+				Str("url", urlString).
+				Str("method", method).
+				Int("status_code:", resp.StatusCode).
+				Str("body", resp.Body).
+				Msg("200")
 		default:
-			log.Printf("%s,%s,%d\n", urlString, resp.Request.Method, resp.StatusCode)
+			log.Info().
+				Str("url", urlString).
+				Str("method", method).
+				Int("status_code", resp.StatusCode).
+				Msg("non-200")
 		}
 	}
 
diff --git a/cmd/scan_test.go b/cmd/scan_test.go
new file mode 100644
index 0000000..9130e9c
--- /dev/null
+++ b/cmd/scan_test.go
@@ -0,0 +1,105 @@
+/*
+Copyright © 2022 NAME HERE <EMAIL ADDRESS>
+
+*/
+package cmd
+
+import (
+	"fmt"
+	"io"
+	"net/http"
+	"reflect"
+	"strings"
+	"testing"
+)
+
+type fakeTransport struct {
+	http.RoundTripper
+}
+
+func (f *fakeTransport) RoundTrip(r *http.Request) (*http.Response, error) {
+	switch r.Method {
+	// GET's 200
+	case http.MethodGet:
+		return &http.Response{
+			StatusCode: 200,
+			Body:       io.NopCloser(strings.NewReader("Hello")),
+		}, nil
+		// OPTIONS calls throw errors
+	case http.MethodOptions:
+		return nil, fmt.Errorf("I've fallen and I can't get up.")
+	default:
+		// Everything else 404s
+		return &http.Response{
+			StatusCode: 404,
+			Body:       io.NopCloser(strings.NewReader("Not Here")),
+		}, nil
+	}
+}
+
+func Test_scanSpecific(t *testing.T) {
+	testClient := &http.Client{
+		Transport: &fakeTransport{},
+	}
+
+	type args struct {
+		method string
+		url    string
+		client *http.Client
+	}
+	tests := []struct {
+		name    string
+		args    args
+		want    *scanResult
+		wantErr bool
+	}{
+		{
+			name: "I got a 200",
+			args: args{
+				method: "GET",
+				url:    "http://example.com",
+				client: testClient,
+			},
+			want: &scanResult{
+				StatusCode: 200,
+				Body:       "Hello",
+			},
+			wantErr: false,
+		},
+		{
+			name: "I got a non-200",
+			args: args{
+				method: "POST",
+				url:    "http://example.com",
+				client: testClient,
+			},
+			want: &scanResult{
+				StatusCode: 404,
+				Body:       "Not Here",
+			},
+			wantErr: false,
+		},
+		{
+			name: "I got an http error",
+			args: args{
+				method: "OPTIONS",
+				url:    "http://example.com",
+				client: testClient,
+			},
+			want:    nil,
+			wantErr: true,
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			got, err := scanSpecific(tt.args.method, tt.args.url, tt.args.client)
+			if (err != nil) != tt.wantErr {
+				t.Errorf("scanSpecific() error = %v, wantErr %v", err, tt.wantErr)
+				return
+			}
+			if !reflect.DeepEqual(got, tt.want) {
+				t.Errorf("scanSpecific() = %v, want %v", got, tt.want)
+			}
+		})
+	}
+}
diff --git a/janus b/janus
deleted file mode 100755
index b8e08b8..0000000
Binary files a/janus and /dev/null differ
